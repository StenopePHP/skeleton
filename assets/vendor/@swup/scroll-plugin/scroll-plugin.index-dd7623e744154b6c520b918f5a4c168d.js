/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@swup/scroll-plugin@3.3.1/dist/index.modern.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import o from"@swup/plugin";import{queryAll as t}from"swup";import s from"scrl";function e(){return e=Object.assign?Object.assign.bind():function(o){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(o[e]=s[e])}return o},e.apply(this,arguments)}class l extends o{constructor(o={}){super(),this.name="SwupScrollPlugin",this.requires={swup:">=4.2.0"},this.scrl=void 0,this.defaults={doScrollingRightAway:!1,animateScroll:{betweenPages:!0,samePageWithHash:!0,samePage:!0},scrollFriction:.3,scrollAcceleration:.04,getAnchorElement:void 0,offset:0,scrollContainers:"[data-swup-scroll-container]",shouldResetScrollPosition:()=>!0,markScrollTarget:!1},this.options=void 0,this.cachedScrollPositions={},this.previousScrollRestoration=void 0,this.currentCacheKey=void 0,this.getAnchorElement=(o="")=>"function"==typeof this.options.getAnchorElement?this.options.getAnchorElement(o):this.swup.getAnchorElement(o),this.getOffset=o=>o?"function"==typeof this.options.offset?parseInt(String(this.options.offset(o)),10):parseInt(String(this.options.offset),10):0,this.onBeforeLinkToSelf=o=>{o.scroll.animate=this.shouldAnimate("samePage")},this.handleScrollToTop=o=>{var t,s;return null==(t=(s=this.swup).scrollTo)||t.call(s,0,o.scroll.animate),!0},this.onBeforeLinkToAnchor=o=>{o.scroll.animate=this.shouldAnimate("samePageWithHash")},this.handleScrollToAnchor=(o,{hash:t})=>this.maybeScrollToAnchor(t,o.scroll.animate),this.onBeforeVisitStart=o=>{o.scroll.scrolledToContent=!1,o.scroll.animate=this.shouldAnimate("betweenPages")},this.onVisitStart=o=>{var t;this.cacheScrollPositions(o.from.url),this.maybeResetScrollPositions(o);const s=null!=(t=o.scroll.target)?t:o.to.hash;o.scroll.animate&&this.options.doScrollingRightAway&&!s&&this.doScrollingBetweenPages(o)},this.handleScrollToContent=o=>{o.scroll.scrolledToContent||this.doScrollingBetweenPages(o),this.restoreScrollContainers(o.to.url)},this.doScrollingBetweenPages=o=>{var t,s;if(o.history.popstate&&!o.animation.animate)return;const e=null!=(t=o.scroll.target)?t:o.to.hash;if(e&&this.maybeScrollToAnchor(e,o.scroll.animate))return;if(!o.scroll.reset)return;const l=this.getCachedScrollPositions(o.to.url),r=(null==l||null==(s=l.window)?void 0:s.top)||0;requestAnimationFrame((()=>{var t,s;return null==(t=(s=this.swup).scrollTo)?void 0:t.call(s,r,o.scroll.animate)})),o.scroll.scrolledToContent=!0},this.maybeResetScrollPositions=o=>{const{popstate:t}=o.history,{url:s}=o.to,{el:e}=o.trigger;t||e&&!this.options.shouldResetScrollPosition(e)||this.resetScrollPositions(s)},this.options=e({},this.defaults,o)}mount(){const o=this.swup;o.hooks.create("scroll:start"),o.hooks.create("scroll:end"),this.scrl=new s({onStart:()=>o.hooks.callSync("scroll:start",void 0),onEnd:()=>o.hooks.callSync("scroll:end",void 0),onCancel:()=>o.hooks.callSync("scroll:end",void 0),friction:this.options.scrollFriction,acceleration:this.options.scrollAcceleration}),o.scrollTo=(t,s=!0)=>{s?this.scrl.scrollTo(t):(o.hooks.callSync("scroll:start",void 0),window.scrollTo(0,t),o.hooks.callSync("scroll:end",void 0))},this.previousScrollRestoration=window.history.scrollRestoration,o.options.animateHistoryBrowsing&&(window.history.scrollRestoration="manual"),this.updateScrollTarget=this.updateScrollTarget.bind(this),this.options.markScrollTarget&&(window.addEventListener("popstate",this.updateScrollTarget),window.addEventListener("hashchange",this.updateScrollTarget),this.on("page:view",this.updateScrollTarget),this.on("link:anchor",this.updateScrollTarget),this.on("link:self",this.updateScrollTarget),this.updateScrollTarget()),this.before("visit:start",this.onBeforeVisitStart,{priority:-1}),this.on("visit:start",this.onVisitStart,{priority:1}),this.replace("content:scroll",this.handleScrollToContent),this.before("link:self",this.onBeforeLinkToSelf,{priority:-1}),this.replace("scroll:top",this.handleScrollToTop),this.before("link:anchor",this.onBeforeLinkToAnchor,{priority:-1}),this.replace("scroll:anchor",this.handleScrollToAnchor)}unmount(){super.unmount(),this.previousScrollRestoration&&(window.history.scrollRestoration=this.previousScrollRestoration),window.removeEventListener("popstate",this.updateScrollTarget),window.removeEventListener("hashchange",this.updateScrollTarget),this.cachedScrollPositions={},delete this.swup.scrollTo,delete this.scrl}shouldAnimate(o){return"boolean"==typeof this.options.animateScroll?this.options.animateScroll:this.options.animateScroll[o]}maybeScrollToAnchor(o,t=!1){var s,e;if(!o)return!1;const l=this.getAnchorElement(o);if(!l)return console.warn(`Anchor target ${o} not found`),!1;if(!(l instanceof Element))return console.warn(`Anchor target ${o} is not a DOM node`),!1;const{top:r}=l.getBoundingClientRect(),i=r+window.scrollY-this.getOffset(l);return null==(s=(e=this.swup).scrollTo)||s.call(e,i,t),!0}cacheScrollPositions(o){const s=this.swup.resolveUrl(o),e=t(this.options.scrollContainers).map((o=>({top:o.scrollTop,left:o.scrollLeft}))),l={window:{top:window.scrollY,left:window.scrollX},containers:e};this.cachedScrollPositions[s]=l}resetScrollPositions(o){const t=this.swup.resolveUrl(o);delete this.cachedScrollPositions[t]}getCachedScrollPositions(o){const t=this.swup.resolveUrl(o);return this.cachedScrollPositions[t]}restoreScrollContainers(o){const s=this.getCachedScrollPositions(o);s&&0!==s.containers.length&&t(this.options.scrollContainers).forEach(((o,t)=>{const e=s.containers[t];null!=e&&(o.scrollTop=e.top,o.scrollLeft=e.left)}))}updateScrollTarget(){var o;const{hash:t}=window.location,s=document.querySelector("[data-swup-scroll-target]");let e=this.getAnchorElement(t);e instanceof HTMLBodyElement&&(e=null),s!==e&&(null==s||s.removeAttribute("data-swup-scroll-target"),null==(o=e)||o.setAttribute("data-swup-scroll-target",""))}}export{l as default};
